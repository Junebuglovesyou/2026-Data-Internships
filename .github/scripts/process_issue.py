import os
import re

# --- Main Configuration ---
ISSUE_BODY = os.environ.get('ISSUE_BODY', '')
INTERNSHIPS_DIR = 'internships'
README_PATH = 'README.md'

# --- Helper Functions ---

def slugify(value):
    """
    Normalizes string, converts to lowercase, removes non-alpha characters,
    and converts spaces to hyphens.
    """
    value = value.lower()
    value = re.sub(r'[^a-z0-9\s-]+', '', value).strip()
    value = re.sub(r'[\s-]+', '-', value)
    return value

def parse_issue_body(body):
    """
    Parses the GitHub issue body generated by a YAML form.
    It looks for '### Field' headers and the value on the next line.
    """
    fields = {}
    # Split the body into lines for processing
    lines = body.replace('\r', '').split('\n')
    
    key_pattern = re.compile(r"###\s+(.+)")
    
    i = 0
    while i < len(lines):
        match = key_pattern.match(lines[i])
        if match:
            # Sanitize the key from the form's label
            key = match.group(1).strip().lower().replace(' (optional)', '').replace(' ', '-')
            
            # The value is expected on the next non-empty line
            if i + 1 < len(lines):
                value = lines[i+1].strip()
                if value and value != "_No response_":
                    fields[key] = value
                else:
                    fields[key] = "" # Store as empty if no response
                i += 1 # Move past the value line
        i += 1
        
    return fields

def create_internship_file(data):
    """Creates a new markdown file for a single internship."""
    
    company = data.get('company-name', 'unknown-company')
    title = data.get('internship-title', 'unknown-internship')
    
    # Create a clean filename
    filename = f"{slugify(company)}-{slugify(title)}.md"
    filepath = os.path.join(INTERNSHIPS_DIR, filename)

    # Ensure the output directory exists
    os.makedirs(INTERNSHIPS_DIR, exist_ok=True)

    # Generate the content for the file
    content = f"""---
company: "{company}"
title: "{title}"
location: "{data.get('location', '')}"
link: "{data.get('link-to-internship-posting', '')}"
season: "{data.get('season', '')}"
sponsorship: "{data.get('sponsorship', '')}"
accepting_applications: "{data.get('is-the-internship-accepting-applications?', '')}"
---

# {title} at {company}

| Detail | Information |
|---|---|
| **Company** | {company} |
| **Location** | {data.get('location', 'N/A')} |
| **Season** | {data.get('season', 'N/A')} |
| **Sponsorship** | {data.get('sponsorship', 'N/A')} |
| **Accepting Applications** | {data.get('is-the-internship-accepting-applications?', 'N/A')} |

**[Apply Here]({data.get('link-to-internship-posting', '#')})**
"""
    
    notes = data.get('extra-notes', '')
    if notes:
        content += f"\n## Notes\n{notes}\n"

    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"Successfully created internship file: {filepath}")

def update_readme_table():
    """
    Scans the internships directory, rebuilds the summary table,
    and injects it into README.md.
    """
    rows_data = []
    for fname in os.listdir(INTERNSHIPS_DIR):
        if fname.endswith('.md'):
            filepath = os.path.join(INTERNSHIPS_DIR, fname)
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
                # Extract metadata from the YAML front matter
                meta = {}
                for line in content.split('---')[1].split('\n'):
                    if ':' in line:
                        key, val = line.split(':', 1)
                        meta[key.strip()] = val.strip().strip('"')
                rows_data.append(meta)

    # Build the markdown table
    header = '| Company | Internship Title | Location | Season | Sponsorship | Accepting | Link |\n'
    header += '|---|---|---|---|---|---|---|\n'
    
    table = header
    for meta in sorted(rows_data, key=lambda x: x.get('company', '')):
        link = f"[Apply]({meta.get('link', '#')})"
        table += f"| {meta.get('company', 'N/A')} | {meta.get('title', 'N/A')} | {meta.get('location', 'N/A')} | {meta.get('season', 'N/A')} | {meta.get('sponsorship', 'N/A')} | {meta.get('accepting_applications', 'N/A')} | {link} |\n"

    # Read the README and replace the table
    with open(README_PATH, 'r', encoding='utf-8') as f:
        readme_content = f.read()

    start_marker = '<!-- INTERNSHIP_TABLE_START -->'
    end_marker = '<!-- INTERNSHIP_TABLE_END -->'
    
    # Replace the content between the markers
    pattern = re.compile(f"({re.escape(start_marker)}).*?({re.escape(end_marker)})", re.DOTALL)
    new_readme = pattern.sub(f'\\1\n{table}\n\\2', readme_content)

    with open(README_PATH, 'w', encoding='utf-8') as f:
        f.write(new_readme)
    print("Successfully updated README.md with the new internship table.")

# --- Main Execution Logic ---

def main():
    if not ISSUE_BODY:
        print("Error: ISSUE_BODY environment variable not found. Exiting.")
        return

    # 1. Parse the data from the issue that triggered the workflow
    internship_data = parse_issue_body(ISSUE_BODY)
    
    # 2. Create a new .md file for this single internship
    create_internship_file(internship_data)
    
    # 3. Re-generate the summary table in the README
    update_readme_table()

if __name__ == "__main__":
    main()
